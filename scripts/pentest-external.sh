#!/usr/bin/env bash
set -euo pipefail

COMPOSE_FILE=${COMPOSE_FILE:-infra/docker-compose/docker-compose.yml}
ENV_FILE=${ENV_FILE:-.env}
if [ ! -f "$ENV_FILE" ]; then
  ENV_FILE=.env.example
fi

AUTH_MODE=${AUTH_MODE:-oidc_hs256}
ALLOW_INSECURE_AUTH_OFF=${ALLOW_INSECURE_AUTH_OFF:-false}
export AUTH_MODE
export ALLOW_INSECURE_AUTH_OFF

BASE=${BASE:-http://127.0.0.1:8080}
POLICY=${POLICY:-http://127.0.0.1:8082}
STATE=${STATE:-http://127.0.0.1:8083}
VERIFIER=${VERIFIER:-http://127.0.0.1:8081}

STAMP=$(date -u +"%Y%m%dT%H%M%SZ")
REPORT_DIR=${REPORT_DIR:-reports/pentest/$STAMP}
FINDINGS_FILE="$REPORT_DIR/findings.ndjson"
PASSES_FILE="$REPORT_DIR/passes.log"
SUMMARY_FILE="$REPORT_DIR/summary.json"
MD_REPORT="$REPORT_DIR/pentest-report.md"
KEEP_STACK=${KEEP_STACK:-false}

mkdir -p "$REPORT_DIR"
touch "$FINDINGS_FILE" "$PASSES_FILE"

dc() {
  docker compose --env-file "$ENV_FILE" -f "$COMPOSE_FILE" "$@"
}

cleanup() {
  rm -f "$REPORT_DIR/oversized.json" >/dev/null 2>&1 || true
  if [ "$KEEP_STACK" != "true" ]; then
    dc down -v >/dev/null 2>&1 || true
  fi
}
trap cleanup EXIT

need() {
  command -v "$1" >/dev/null 2>&1 || {
    echo "missing dependency: $1" >&2
    exit 1
  }
}

need curl
need jq
need nc
need python3
need docker

env_value() {
  local key="$1"
  local raw
  raw=$(grep -E "^${key}=" "$ENV_FILE" | tail -n 1 | cut -d'=' -f2- || true)
  printf "%s" "${raw}"
}

add_pass() {
  local check="$1"
  local detail="$2"
  printf "[PASS] %s: %s\n" "$check" "$detail" | tee -a "$PASSES_FILE" >/dev/null
}

add_finding() {
  local severity="$1"
  local check="$2"
  local title="$3"
  local evidence="$4"
  local remediation="$5"
  jq -nc \
    --arg severity "$severity" \
    --arg check "$check" \
    --arg title "$title" \
    --arg evidence "$evidence" \
    --arg remediation "$remediation" \
    '{severity:$severity,check:$check,title:$title,evidence:$evidence,remediation:$remediation}' >>"$FINDINGS_FILE"
  printf "[%s] %s: %s\n" "$severity" "$check" "$title"
}

wait_for() {
  local url="$1"
  local max="${2:-60}"
  local i=0
  until curl -fsS "$url" >/dev/null 2>&1; do
    i=$((i + 1))
    if [ "$i" -ge "$max" ]; then
      echo "timeout waiting for $url" >&2
      return 1
    fi
    sleep 2
  done
}

mint_jwt() {
  local secret="$1"
  local subject="$2"
  local roles_csv="$3"
  local tenant="$4"
  local ttl="$5"
  python3 - "$secret" "$subject" "$roles_csv" "$tenant" "$ttl" <<'PY'
import base64
import hashlib
import hmac
import json
import sys
import time

secret, subject, roles_csv, tenant, ttl = sys.argv[1], sys.argv[2], sys.argv[3], sys.argv[4], int(sys.argv[5])
roles = [r.strip() for r in roles_csv.split(",") if r.strip()]
now = int(time.time())
header = {"alg": "HS256", "typ": "JWT"}
payload = {
    "sub": subject,
    "roles": roles,
    "tenant": tenant,
    "iat": now,
    "nbf": now - 1,
    "exp": now + ttl,
}

def b64(data):
    raw = json.dumps(data, separators=(",", ":"), sort_keys=True).encode()
    return base64.urlsafe_b64encode(raw).rstrip(b"=").decode()

head = b64(header)
body = b64(payload)
msg = f"{head}.{body}".encode()
sig = hmac.new(secret.encode(), msg, hashlib.sha256).digest()
token = f"{head}.{body}.{base64.urlsafe_b64encode(sig).rstrip(b'=').decode()}"
print(token)
PY
}

expect_code() {
  local check="$1"
  local expected="$2"
  local got="$3"
  local evidence="$4"
  if [ "$got" = "$expected" ]; then
    add_pass "$check" "expected HTTP $expected"
  else
    add_finding "HIGH" "$check" "unexpected HTTP status" "expected=$expected got=$got; $evidence" "review auth/middleware/route protection for this endpoint"
  fi
}

echo "bringing up stack for external pentest"
dc up -d --build >/dev/null
wait_for "$BASE/healthz" 90
wait_for "$POLICY/healthz" 90
wait_for "$STATE/healthz" 90
wait_for "$VERIFIER/healthz" 90

echo "collecting externally reachable ports"
OPEN_PORTS=""
for p in 8080 8081 8082 8083 8084 8085; do
  if nc -z 127.0.0.1 "$p" >/dev/null 2>&1; then
    OPEN_PORTS="$OPEN_PORTS $p"
  fi
done
OPEN_PORTS=$(echo "$OPEN_PORTS" | xargs || true)
echo "$OPEN_PORTS" >"$REPORT_DIR/open-ports.txt"

for required in 8080 8081 8082 8083; do
  if echo " $OPEN_PORTS " | grep -q " $required "; then
    add_pass "PORT_$required" "port $required reachable"
  else
    add_finding "HIGH" "PORT_$required" "expected service port not reachable" "port=$required open_ports=[$OPEN_PORTS]" "verify service startup and network policy"
  fi
done
if echo " $OPEN_PORTS " | grep -q " 8084 " || echo " $OPEN_PORTS " | grep -q " 8085 "; then
  add_finding "MEDIUM" "PORT_SCOPE" "non-gateway mock ports are exposed" "open_ports=[$OPEN_PORTS]" "remove host exposure for non-public adapters in production topology"
else
  add_pass "PORT_SCOPE" "only expected public ports are host-reachable in tested range"
fi

echo "checking baseline security headers"
for port in 8080 8081 8082 8083; do
  hdr="$REPORT_DIR/headers-$port.txt"
  curl -sSI "http://127.0.0.1:$port/healthz" >"$hdr"
  if grep -iq '^x-content-type-options: nosniff' "$hdr" &&
    grep -iq '^x-frame-options: DENY' "$hdr" &&
    grep -iq '^referrer-policy: no-referrer' "$hdr" &&
    grep -iq '^content-security-policy:' "$hdr" &&
    grep -iq '^strict-transport-security:' "$hdr"; then
    add_pass "HEADERS_$port" "security headers present"
  else
    add_finding "MEDIUM" "HEADERS_$port" "missing security headers" "see $hdr" "enforce SecurityHeadersMiddleware on all routers and endpoints"
  fi
done

HS_SECRET=$(env_value OIDC_HS256_SECRET)
if [ -z "$HS_SECRET" ]; then
  add_finding "HIGH" "AUTH_SETUP" "OIDC_HS256_SECRET is empty" "env_file=$ENV_FILE" "configure HS256 secret before running auth-enabled environments"
  exit 1
fi

TOKEN_OPERATOR=$(mint_jwt "$HS_SECRET" "pentest-operator" "operator" "acme" 1800)
TOKEN_SECURITY=$(mint_jwt "$HS_SECRET" "pentest-security" "securityadmin" "acme" 1800)
TOKEN_COMPLIANCE=$(mint_jwt "$HS_SECRET" "pentest-compliance" "complianceofficer" "acme" 1800)
TOKEN_TAMPERED="${TOKEN_OPERATOR}x"

echo "running authn/authz negative tests"
code=$(curl -sS -o /dev/null -w "%{http_code}" "$BASE/v1/verdicts")
expect_code "AUTH_GATEWAY_NONE" "401" "$code" "$BASE/v1/verdicts"

code=$(curl -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN_TAMPERED" "$BASE/v1/verdicts")
expect_code "AUTH_GATEWAY_TAMPERED" "401" "$code" "$BASE/v1/verdicts"

code=$(curl -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN_OPERATOR" "$BASE/v1/verdicts")
expect_code "AUTH_GATEWAY_OPERATOR" "200" "$code" "$BASE/v1/verdicts"

code=$(curl -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN_OPERATOR" "$BASE/v1/compliance/subjects/restrictions")
expect_code "RBAC_GATEWAY_COMPLIANCE_DENY" "403" "$code" "$BASE/v1/compliance/subjects/restrictions"

code=$(curl -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN_SECURITY" "$BASE/v1/compliance/subjects/restrictions")
expect_code "RBAC_GATEWAY_SECURITY_ALLOW" "200" "$code" "$BASE/v1/compliance/subjects/restrictions"

code=$(curl -sS -o /dev/null -w "%{http_code}" "$POLICY/v1/keys")
expect_code "AUTH_POLICY_NONE" "401" "$code" "$POLICY/v1/keys"

code=$(curl -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN_OPERATOR" "$POLICY/v1/keys")
expect_code "RBAC_POLICY_OPERATOR_DENY" "403" "$code" "$POLICY/v1/keys"

code=$(curl -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN_SECURITY" "$POLICY/v1/keys")
expect_code "RBAC_POLICY_SECURITY_ALLOW" "200" "$code" "$POLICY/v1/keys"

code=$(curl -sS -o /dev/null -w "%{http_code}" "$STATE/v1/beliefstate?domain=finance&tenant=acme")
expect_code "AUTH_STATE_NONE" "401" "$code" "$STATE/v1/beliefstate"

code=$(curl -sS -o /dev/null -w "%{http_code}" -X POST -H 'content-type: application/json' -d '{}' "$VERIFIER/v1/verify")
expect_code "AUTH_VERIFIER_NONE" "401" "$code" "$VERIFIER/v1/verify"

echo "checking internal endpoint token-gate"
internal_path="$POLICY/v1/internal/policysets/pentest/versions/v1"
code=$(curl -sS -o /dev/null -w "%{http_code}" "$internal_path")
expect_code "INTERNAL_TOKEN_NONE" "401" "$code" "$internal_path"

code=$(curl -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOKEN_SECURITY" "$internal_path")
expect_code "INTERNAL_TOKEN_BEARER_ONLY" "401" "$code" "$internal_path"

POLICY_AUTH_HEADER=$(env_value POLICY_AUTH_HEADER)
POLICY_AUTH_TOKEN=$(env_value POLICY_AUTH_TOKEN)
if [ -n "$POLICY_AUTH_HEADER" ] && [ -n "$POLICY_AUTH_TOKEN" ]; then
  code=$(curl -sS -o /dev/null -w "%{http_code}" -H "$POLICY_AUTH_HEADER: $POLICY_AUTH_TOKEN" "$internal_path")
  case "$code" in
  200 | 404)
    add_pass "INTERNAL_TOKEN_VALID" "internal token accepted (status $code)"
    ;;
  *)
    add_finding "HIGH" "INTERNAL_TOKEN_VALID" "valid internal token was not accepted" "status=$code path=$internal_path" "verify internal token middleware and service credentials"
    ;;
  esac
else
  add_finding "MEDIUM" "INTERNAL_TOKEN_CONFIG" "internal policy token is not configured in env file" "env_file=$ENV_FILE" "configure POLICY_AUTH_HEADER and POLICY_AUTH_TOKEN for internal trust boundary"
fi

echo "checking CORS behavior"
CORS_ALLOWED=$(env_value CORS_ALLOWED_ORIGINS)
CORS_FIRST=$(echo "$CORS_ALLOWED" | cut -d',' -f1 | xargs || true)
if [ -n "$CORS_FIRST" ]; then
  pre_ok_code=$(curl -sS -o /dev/null -w "%{http_code}" -X OPTIONS \
    -H "Origin: $CORS_FIRST" \
    -H "Access-Control-Request-Method: GET" \
    "$BASE/v1/verdicts")
  pre_ok_hdr=$(curl -sS -D - -o /dev/null -X OPTIONS \
    -H "Origin: $CORS_FIRST" \
    -H "Access-Control-Request-Method: GET" \
    "$BASE/v1/verdicts")
  if [ "$pre_ok_code" = "204" ] && echo "$pre_ok_hdr" | grep -iq "Access-Control-Allow-Origin: $CORS_FIRST"; then
    add_pass "CORS_ALLOWED_ORIGIN" "allowlisted origin accepted"
  else
    add_finding "MEDIUM" "CORS_ALLOWED_ORIGIN" "allowlisted origin rejected or not echoed" "origin=$CORS_FIRST status=$pre_ok_code" "validate CORS_ALLOWED_ORIGINS and reverse-proxy header forwarding"
  fi
fi

pre_bad_code=$(curl -sS -o /dev/null -w "%{http_code}" -X OPTIONS \
  -H "Origin: https://evil.example" \
  -H "Access-Control-Request-Method: GET" \
  "$BASE/v1/verdicts")
if [ "$pre_bad_code" = "403" ]; then
  add_pass "CORS_BLOCK_EVIL" "disallowed preflight blocked"
else
  add_finding "HIGH" "CORS_BLOCK_EVIL" "disallowed origin preflight not blocked" "status=$pre_bad_code origin=https://evil.example" "tighten CORS allowlist and reject disallowed preflight requests"
fi

echo "checking oversized body handling"
python3 - <<'PY' >"$REPORT_DIR/oversized.json"
import json
print(json.dumps({"blob": "A" * (2 * 1024 * 1024)}))
PY
code=$(curl -sS -o "$REPORT_DIR/oversized-response.txt" -w "%{http_code}" \
  -H "Authorization: Bearer $TOKEN_OPERATOR" \
  -H 'content-type: application/json' \
  --data-binary "@$REPORT_DIR/oversized.json" \
  "$BASE/v1/tool/execute")
case "$code" in
400 | 413)
  add_pass "BODY_LIMIT_GATEWAY" "oversized request rejected with status $code"
  ;;
*)
  add_finding "HIGH" "BODY_LIMIT_GATEWAY" "oversized request was not rejected" "status=$code response_file=$REPORT_DIR/oversized-response.txt" "enforce MAX_REQUEST_BODY_BYTES and reject oversized inputs before decode"
  ;;
esac

echo "checking injection-style payload handling"
code=$(curl -sS -o "$REPORT_DIR/injection-response.txt" -w "%{http_code}" \
  -H "Authorization: Bearer $TOKEN_SECURITY" \
  "$BASE/v1/beliefstate?domain=finance%27%20OR%201%3D1--&tenant=acme")
if [ "$code" = "500" ]; then
  add_finding "HIGH" "INJECTION_RESILIENCE" "injection-like query caused server error" "status=500 endpoint=$BASE/v1/beliefstate" "harden input validation and query parameter handling"
else
  add_pass "INJECTION_RESILIENCE" "injection-like query did not cause server error (status $code)"
fi

echo "generating pentest summary"
jq -s '.' "$FINDINGS_FILE" >"$REPORT_DIR/findings.json"

high_count=$(jq '[.[] | select(.severity=="HIGH")] | length' "$REPORT_DIR/findings.json")
medium_count=$(jq '[.[] | select(.severity=="MEDIUM")] | length' "$REPORT_DIR/findings.json")
low_count=$(jq '[.[] | select(.severity=="LOW")] | length' "$REPORT_DIR/findings.json")
info_count=$(jq '[.[] | select(.severity=="INFO")] | length' "$REPORT_DIR/findings.json")
pass_count=$(wc -l <"$PASSES_FILE" | tr -d ' ')

jq -n \
  --arg timestamp "$STAMP" \
  --arg env_file "$ENV_FILE" \
  --arg compose_file "$COMPOSE_FILE" \
  --arg open_ports "$OPEN_PORTS" \
  --argjson passes "${pass_count:-0}" \
  --argjson high "$high_count" \
  --argjson medium "$medium_count" \
  --argjson low "$low_count" \
  --argjson info "$info_count" \
  '{
    executed_at_utc:$timestamp,
    env_file:$env_file,
    compose_file:$compose_file,
    open_ports:$open_ports,
    passes:$passes,
    findings:{high:$high,medium:$medium,low:$low,info:$info}
  }' >"$SUMMARY_FILE"

{
  echo "# External Pentest Report"
  echo
  echo "- Executed at (UTC): \`$STAMP\`"
  echo "- Compose file: \`$COMPOSE_FILE\`"
  echo "- Env file: \`$ENV_FILE\`"
  echo "- Open ports (tested range 8080-8085): \`$OPEN_PORTS\`"
  echo "- Pass checks: \`$pass_count\`"
  echo "- Findings: HIGH=\`$high_count\`, MEDIUM=\`$medium_count\`, LOW=\`$low_count\`, INFO=\`$info_count\`"
  echo
  echo "## Findings"
  if [ "$(jq 'length' "$REPORT_DIR/findings.json")" -eq 0 ]; then
    echo "No findings."
  else
    jq -r '.[] | "- [" + .severity + "] **" + .check + "** - " + .title + " | evidence: " + .evidence + " | remediation: " + .remediation' "$REPORT_DIR/findings.json"
  fi
  echo
  echo "## Pass Checks"
  sed 's/^/- /' "$PASSES_FILE"
} >"$MD_REPORT"

echo "pentest artifacts:"
echo "  summary:  $SUMMARY_FILE"
echo "  findings: $REPORT_DIR/findings.json"
echo "  report:   $MD_REPORT"

if [ "$high_count" -gt 0 ]; then
  echo "external pentest failed: HIGH findings=$high_count"
  exit 1
fi

echo "external pentest passed: no HIGH findings"
